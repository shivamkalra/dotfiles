#+TITLE:   Shivam's Emacs Configuration
#+AUTHOR:  Shivam Kalra
#+EMAIL:   shivam.s.kalra@gmail.com
#+LANGUAGE: en
#+PROPERTY: header-args :tangle yes
#+EXPORT_SELECT_TAGS: export
#+EXPORT_EXCLUDE_TAGS: noexport
#+OPTIONS: H:4 num:nil toc:t \n:nil @:t ::t |:t ^:{} -:t f:t *:t
#+OPTIONS: skip:nil d:(HIDE) tags:not-in-toc
#+TODO: SOMEDAY(s) TODO(t) INPROGRESS(i) WAITING(w@/!) NEEDSREVIEW(n@/!) | DONE(d)
#+TODO: WAITING(w@/!) HOLD(h@/!) | CANCELLED(c@/!)
#+TAGS: export(e) noexport(n)
#+STARTUP: align fold nodlcheck lognotestate content
* References
My Emacs configuration is heavily inspired from various publicly
available Emacs configurations on the internet. I'm listing them
below:
1. [[http://p.writequit.org/org/settings.html][Lee's Emacs settings file]]
2. [[http://pages.sachachua.com/.emacs.d/Sacha.html][Sacha Chua's Emacs configuration]]
3. [[https://github.com/emacs-tw/awesome-emacs][Awesome Emacs packages]]
* Introduction
This file is used by =org-babel= to load my personal Emacs
settings. This file is loaded from =init.el=:

#+BEGIN_SRC
  (require 'org)
  (org-babel-load-file
   (expand-file-name "settings.org"
                     user-emacs-directory))
#+END_SRC
** Package installation
I'm using [[https://github.com/cask/cask][Cask]] to manage dependencies for my local Emacs
configuration. It can be installed from [[https://github.com/cask/cask][here]].

Cask defines a domain-specific language for maintaining =elisp=
dependencies, which goes into my =~/.emacs.d/Cask= file. Run =cask
install= command in terminal from =~/.emacs.d/= directory to install
all the dependencies.

I'm using [[https://github.com/rdallasgray/pallet][Pallet]] to keep =~/.emacs.d/Cask= synchronized with packages
that are installed or removed through in-build Emacs package management
tool. Cask and Pallet is initialized from =init.el=:

#+BEGIN_SRC
  ;; Package Manager
  (require 'cask "~/.cask/cask.el")
  (cask-initialize)
  (require 'pallet)
  (pallet-mode t)
  ;; Keeps ~Cask~ file in sync with the packages
  (require 'pallet)
#+END_SRC
* Configuration
** Appearance, look and feel
*** Menu and toolbar
Disable all menu and toolbar to claim every little screen-space.

#+BEGIN_SRC emacs-lisp
 (progn
   (dolist (mode '(menu-bar-mode tool-bar-mode scroll-bar-mode))
     (when (fboundp mode) (funcall mode -1))))
#+END_SRC
*** Theme
I use =solarized-dark= theme when Emacs is as X window application
whereas =wombat= on my =rxvt= terminal.

#+BEGIN_SRC emacs-lisp
  ;; solarized-dark on window-system
  ;; wombat on terminal
  (if (display-graphic-p)
      (progn
        ;; https://github.com/bbatsov/solarized-emacs/issues/87
        (setq solarized-use-variable-pitch nil)
        (load-theme 'solarized-dark t))
    (load-theme 'wombat t))
#+END_SRC
*** Fonts
I have been using [[http://openfontlibrary.org/en/font/fantasque-sans-mono][Fantasque Sans Mono]] lately and it looks pretty nice
to me.

#+BEGIN_SRC emacs-lisp
  (add-to-list 'default-frame-alist
               '(font . "Fantasque Sans Mono-10:weight=black"))
#+END_SRC
*** Modelines
#+BEGIN_SRC emacs-lisp
  ;; line/column numbers in mode-line
  (line-number-mode)
  (column-number-mode)

  ;; show function in modeline
  (which-function-mode)
#+END_SRC
*** Misc.
Disable annoying bell sound and startup screen..geez..
#+BEGIN_SRC emacs-lisp
  (setq inhibit-startup-message t)
  (setq ring-bell-function 'ignore)
#+END_SRC
** General settings
Things that cannot be categorized but applies everywhere in Emacs go here.
*** Personal information
#+BEGIN_SRC emacs-lisp
  (setq user-full-name "Shivam Kalra"
        user-mail-address "shivam.s.kalra@gmail.com")
#+END_SRC
*** Backups and temporary files
By default Emacs saves backups of files in working directory. To
prevent Emacs cluttering current working directory with files ending
with =~= add this:

#+BEGIN_SRC emacs-lisp
  ;; savehist
  (setq savehist-additional-variables
        ;; also save my search entries
        '(search-ring regexp-search-ring)
        savehist-file "~/.emacs.d/savehist")
  (savehist-mode t)
  (setq-default save-place t)

  ;; delete-auto-save-files
  (setq delete-auto-save-files t)
  (setq backup-directory-alist
        '(("." . "~/.emacs.d/backups")))

  ;; delete old backups silently
  (setq delete-old-versions t)
#+END_SRC
*** Clipboard settings
Change the clipboard settings to better integrate into Linux:

#+BEGIN_SRC emacs-lisp
  (setq x-select-enable-clipboard t)
  ;; Treat clipboard input as UTF-8 string first; compound text next, etc.
  (setq x-select-request-type '(UTF8_STRING COMPOUND_TEXT TEXT STRING))
#+END_SRC

Save whatever's in the current (system) clipboard before replacing it with the
Emacs' text.

#+BEGIN_SRC emacs-lisp
  (setq save-interprogram-paste-before-kill t)
#+END_SRC
*** View-mode and doc-view
Read-only viewing of files. Keybindings for paging through stuff
in a less/vim manner.

#+BEGIN_SRC emacs-lisp
  (use-package view
    :bind
    (("C-M-n" . View-scroll-half-page-forward)
     ("C-M-p" . View-scroll-half-page-backward))
    :config
    (progn
      ;; When in view-mode, the buffer is read-only:
      (setq view-read-only t)

      (defun View-goto-line-last (&optional line)
        "goto last line"
        (interactive "P")
        (goto-line (line-number-at-pos (point-max))))

      ;; less like
      (define-key view-mode-map (kbd "N") 'View-search-last-regexp-backward)
      (define-key view-mode-map (kbd "?") 'View-search-regexp-backward?)
      (define-key view-mode-map (kbd "g") 'View-goto-line)
      (define-key view-mode-map (kbd "G") 'View-goto-line-last)
      ;; vi/w3m like
      (define-key view-mode-map (kbd "h") 'backward-char)
      (define-key view-mode-map (kbd "j") 'next-line)
      (define-key view-mode-map (kbd "k") 'previous-line)
      (define-key view-mode-map (kbd "l") 'forward-char)))

  (use-package doc-view
    :config
    (define-key doc-view-mode-map (kbd "j")
      #'doc-view-next-line-or-next-page)
    (define-key doc-view-mode-map (kbd "k")
      #'doc-view-previous-line-or-previous-page)
    ;; use 'q' to kill the buffer, not just hide it
    (define-key doc-view-mode-map (kbd "q")
      #'kill-this-buffer))
#+END_SRC
*** Recent files
#+BEGIN_SRC emacs-lisp
(defun ido-recentf-open ()
  "Use `ido-completing-read' to \\[find-file] a recent file"
  (interactive)
  (if (find-file (ido-completing-read "Find recent file: " recentf-list))
      (message "Opening file...")
    (message "Aborting")))

(use-package recentf
  :init
  (recentf-mode t)
  :config
  (progn
    (setq recentf-max-saved-items 200
          recentf-max-menu-items 15)
    (bind-key "C-x C-r" 'ido-recentf-open)))
#+END_SRC

*** Disable Yes/No
Replacing =yes= or =no= prompt with =y= or =n=. It is much easier and less annoying.
#+BEGIN_SRC emacs-lisp
(defalias 'yes-or-no-p 'y-or-n-p)
#+END_SRC
*** with-editor
Sets up the =with-editor= package so things that invoke =$EDITOR= will use the
current emacs if I'm already inside of emacs

#+BEGIN_SRC emacs-lisp
(use-package with-editor
  :init
  (progn
    (add-hook 'shell-mode-hook  'with-editor-export-editor)
    (add-hook 'eshell-mode-hook 'with-editor-export-editor)))
#+END_SRC

*** alert (notifications)
#+BEGIN_SRC emacs-lisp
(use-package alert)
#+END_SRC
** Navigation
*** Moving to beginning of file
#+BEGIN_SRC emacs-lisp
  (defun my/smarter-move-beginning-of-line (arg)
    "Move point back to indentation of beginning of line.

  Move point to the first non-whitespace character on this line.
  If point is already there, move to the beginning of the line.
  Effectively toggle between the first non-whitespace character and
  the beginning of the line.

  If ARG is not nil or 1, move forward ARG - 1 lines first.  If
  point reaches the beginning or end of the buffer, stop there."
    (interactive "^p")
    (setq arg (or arg 1))

    ;; Move lines first
    (when (/= arg 1)
      (let ((line-move-visual nil))
        (forward-line (1- arg))))

    (let ((orig-point (point)))
      (back-to-indentation)
      (when (= orig-point (point))
        (move-beginning-of-line 1))))

  ;; remap C-a to `smarter-move-beginning-of-line'
  (global-set-key [remap move-beginning-of-line]
                  'my/smarter-move-beginning-of-line)
#+END_SRC
*** Windmove - jumping between windows
#+BEGIN_SRC emacs-lisp
  (use-package windmove
    :config (windmove-default-keybindings))
#+END_SRC
*** Ace jump - A quick cursor jump mode
#+BEGIN_SRC emacs-lisp
  (use-package ace-jump-mode
    :config (eval-after-load "ace-jump-mode" '(ace-jump-mode-enable-mark-sync))
    :bind (("C-c SPC" . ace-jump-mode)
           ("C-c M-SPC" . ace-jump-line-mode)))
#+END_SRC
*** Save place
Navigates back to where you were editing a file next time you open it

#+BEGIN_SRC emacs-lisp
  (use-package saveplace
    :init
    (setq-default save-place t)
    (setq save-place-file (expand-file-name ".places" user-emacs-directory)))
#+END_SRC
** Interface enhacements
*** smooth-scrolling
Smooth scrolling means when you hit =C-n= to go to the next line at the bottom
of the page, instead of doing a page-down, it shifts down by a single line. The
margin means that much space is kept between the cursor and the bottom of the
buffer.

#+BEGIN_SRC emacs-lisp
(use-package smooth-scrolling
  :config
  (setq smooth-scroll-margin 4))
#+END_SRC
*** smartparens
So, paredit is great, however, it doesn't work for non-lisp modes. Smartparens
works pretty well, so I use it everywhere paredit-mode doesn't work.

#+BEGIN_SRC emacs-lisp
(use-package smartparens
  :bind (("M-9" . sp-backward-sexp)
         ("M-0" . sp-forward-sexp))
  :config
  (progn
    (add-to-list 'sp-sexp-suffix '(json-mode regex ""))
    (add-to-list 'sp-sexp-suffix '(es-mode regex ""))

    (use-package smartparens-config)
    (add-hook 'sh-mode-hook
              (lambda ()
                ;; Remove when https://github.com/Fuco1/smartparens/issues/257
                ;; is fixed
                (setq sp-autoescape-string-quote nil)))

    ;; Remove the M-<backspace> binding that smartparens adds
    (let ((disabled '("M-<backspace>")))
      (setq sp-smartparens-bindings
            (cl-remove-if (lambda (key-command)
                            (member (car key-command) disabled))
                          sp-smartparens-bindings)))

    (define-key sp-keymap (kbd "C-(") 'sp-forward-barf-sexp)
    (define-key sp-keymap (kbd "C-)") 'sp-forward-slurp-sexp)
    (define-key sp-keymap (kbd "M-(") 'sp-forward-barf-sexp)
    (define-key sp-keymap (kbd "M-)") 'sp-forward-slurp-sexp)
    (define-key sp-keymap (kbd "C-M-f") 'sp-forward-sexp)
    (define-key sp-keymap (kbd "C-M-b") 'sp-backward-sexp)
    (define-key sp-keymap (kbd "C-M-f") 'sp-forward-sexp)
    (define-key sp-keymap (kbd "C-M-b") 'sp-backward-sexp)
    (define-key sp-keymap (kbd "C-M-d") 'sp-down-sexp)
    (define-key sp-keymap (kbd "C-M-a") 'sp-backward-down-sexp)
    (define-key sp-keymap (kbd "C-S-a") 'sp-beginning-of-sexp)
    (define-key sp-keymap (kbd "C-S-d") 'sp-end-of-sexp)
    (define-key sp-keymap (kbd "C-M-e") 'sp-up-sexp)
    (define-key emacs-lisp-mode-map (kbd ")") 'sp-up-sexp)
    (define-key sp-keymap (kbd "C-M-u") 'sp-backward-up-sexp)
    (define-key sp-keymap (kbd "C-M-t") 'sp-transpose-sexp)
    ;; (define-key sp-keymap (kbd "C-M-n") 'sp-next-sexp)
    ;; (define-key sp-keymap (kbd "C-M-p") 'sp-previous-sexp)
    (define-key sp-keymap (kbd "C-M-k") 'sp-kill-sexp)
    (define-key sp-keymap (kbd "C-M-w") 'sp-copy-sexp)
    (define-key sp-keymap (kbd "M-D") 'sp-splice-sexp)
    (define-key sp-keymap (kbd "C-]") 'sp-select-next-thing-exchange)
    (define-key sp-keymap (kbd "C-<left_bracket>") 'sp-select-previous-thing)
    (define-key sp-keymap (kbd "C-M-]") 'sp-select-next-thing)
    (define-key sp-keymap (kbd "M-F") 'sp-forward-symbol)
    (define-key sp-keymap (kbd "M-B") 'sp-backward-symbol)
    (define-key sp-keymap (kbd "H-t") 'sp-prefix-tag-object)
    (define-key sp-keymap (kbd "H-p") 'sp-prefix-pair-object)
    (define-key sp-keymap (kbd "H-s c") 'sp-convolute-sexp)
    (define-key sp-keymap (kbd "H-s a") 'sp-absorb-sexp)
    (define-key sp-keymap (kbd "H-s e") 'sp-emit-sexp)
    (define-key sp-keymap (kbd "H-s p") 'sp-add-to-previous-sexp)
    (define-key sp-keymap (kbd "H-s n") 'sp-add-to-next-sexp)
    (define-key sp-keymap (kbd "H-s j") 'sp-join-sexp)
    (define-key sp-keymap (kbd "H-s s") 'sp-split-sexp)

    (sp-local-pair 'minibuffer-inactive-mode "'" nil :actions nil)
    ;; Remove '' pairing in elisp because quoting is used a ton
    (sp-local-pair 'emacs-lisp-mode "'" nil :actions nil)

    (sp-with-modes '(html-mode sgml-mode)
      (sp-local-pair "<" ">"))

    (sp-with-modes sp--lisp-modes
      (sp-local-pair "(" nil :bind "C-("))))


(add-hook 'prog-mode-hook
          (lambda ()
            (smartparens-global-mode t)
            (show-smartparens-global-mode t)))
#+END_SRC
*** ido-mode
First, turn on ido-mode everywhere, and if flx-ido is installed, enable it
everywhere as well.

Ido gives really nice completion while flx-ido makes everything more flexible
instead of rigid completions

#+BEGIN_SRC emacs-lisp
  (use-package ido
    :init (ido-mode t)
    :config
    (progn
      (setq ido-use-virtual-buffers nil
            ;; this setting causes weird TRAMP connections, don't set it!
            ;;ido-enable-tramp-completion nil
            ido-enable-flex-matching t
            ido-auto-merge-work-directories-length nil
            ido-create-new-buffer 'always
            ido-use-filename-at-point 'guess
            ido-max-prospects 10)))

  (use-package flx-ido
    :init (flx-ido-mode t)
    :config
    (setq ido-use-faces nil))

  (use-package ido-vertical-mode
    :init (ido-vertical-mode t))

  (use-package ido-ubiquitous
    :init (ido-ubiquitous 1))
#+END_SRC

*** undo-tree
Undo-tree allows me to have sane undo defaults, as well as being able to
visualize it in ascii art if needed.

#+BEGIN_SRC emacs-lisp
(use-package undo-tree
  :idle (global-undo-tree-mode t)
  :diminish ""
  :config
  (progn
    (define-key undo-tree-map (kbd "C-x u") 'undo-tree-visualize)
    (define-key undo-tree-map (kbd "C-/") 'undo-tree-undo)))
#+END_SRC
*** smex
Smex is IDO, but for =M-x=

#+BEGIN_SRC emacs-lisp
(use-package smex
  :bind (("M-x" . smex)
         ("M-X" . smex-major-mode-commands)))
#+END_SRC
*** multiple-cursors
Mulitple cursors is like rectangular selection/insertion but on steroids

#+BEGIN_SRC emacs-lisp
(use-package multiple-cursors
  :bind (("C-S-c C-S-c" . mc/edit-lines)
         ("C->" . mc/mark-next-like-this)
         ("C-<" . mc/mark-previous-like-this)
         ("C-c C-<" . mc/mark-all-like-this)))
#+END_SRC
*** anzu mode
[[https://github.com/syohex/emacs-anzu][anzu.el]] is an Emacs port of =anzu.vim=. It provides a minor mode
which displays current match and total matches information in the
mode-line in various search modes.

#+BEGIN_SRC emacs-lisp
(use-package anzu
  :bind ("M-%" . anzu-query-replace-regexp)
  :config
  (progn
    (use-package thingatpt)
    (setq anzu-mode-lighter "")
    (set-face-attribute 'anzu-mode-line nil :foreground "yellow")))

(add-hook 'prog-mode-hook (lambda () (anzu-mode t)))
#+END_SRC

Also, add a thing for yanking the entire symbol into the query while searching:

#+BEGIN_SRC emacs-lisp
(defun isearch-yank-symbol ()
  (interactive)
  (isearch-yank-internal (lambda () (forward-symbol 1) (point))))

(define-key isearch-mode-map (kbd "C-M-w") 'isearch-yank-symbol)
#+END_SRC

*** Ibuffer mode
=Ibuffer= is an advanced replacement for BufferMenu, which lets you
operate on buffers much in the same manner as Dired.
#+BEGIN_SRC emacs-lisp
  ;; ibuffer
  (use-package ibuffer
    :config (add-hook 'ibuffer-mode-hook (lambda () (setq truncate-lines t)))
    :bind ("C-x C-b" . ibuffer))
#+END_SRC
*** winner mode
winner-mode lets you use =C-c <left>= and =C-c <right>= to switch
between window configurations. This is handy when something has popped
up a buffer that you want to look at briefly before returning to
whatever you were working on. When you're done, press =C-c <left>=.

#+BEGIN_SRC emacs-lisp
  (use-package winner
    :ensure t
    :defer t
    :idle (winner-mode 1))
#+END_SRC
** File manager and file system
*** General settings
Default directory to open a file is my =project= directory.
#+BEGIN_SRC emacs-lisp
  (setq default-directory "~/projects")
#+END_SRC

Open empty file quietly.
#+BEGIN_SRC emacs-lisp
  (setq confirm-nonexistent-file-or-buffer nil)
#+END_SRC

Follow sysmlinks.
#+BEGIN_SRC emacs-lisp
  (setq vc-follow-symlinks t)
#+END_SRC
*** Dired settings
Dired is sweet, I require =dired-x= also so I can hit =C-x C-j=
and go directly to a dired buffer.

Setting =ls-lisp-dirs-first= means directories are always at the
top. Always copy and delete recursively. Also enable
=hl-line-mode= in dired, since it's easier to see the cursor then.

To start, a helper to use "=open=" to open files in dired-mode with =M-o=
(similar to Finder in OSX).

#+BEGIN_SRC emacs-lisp
  (defun my/dired-mac-open ()
    (interactive)
    (save-window-excursion
      (dired-do-async-shell-command
       "open" current-prefix-arg
       (dired-get-marked-files t current-prefix-arg))))
#+END_SRC

And then some other things to setup when dired runs. =C-x C-q= to edit
writable-dired mode is aawwweeeesssoooommee, it makes renames super easy.

#+BEGIN_SRC emacs-lisp
  (defun my/dired-mode-hook ()
    (hl-line-mode t)
    (toggle-truncate-lines 1))

  (use-package dired
    :bind ("C-x C-j" . dired-jump)
    :config
    (progn
      (use-package dired-x
        :init (setq-default dired-omit-files-p t)
        :config
        (when (eq system-type 'darwin)
          (add-to-list 'dired-omit-extensions ".DS_Store")))
      (customize-set-variable 'diredp-hide-details-initially-flag nil)
      (use-package dired+)
      (use-package dired-aux
        :init (use-package dired-async))
      (put 'dired-find-alternate-file 'disabled nil)
      (setq ls-lisp-dirs-first t
            dired-recursive-copies 'always
            dired-recursive-deletes 'always
            dired-dwim-target t
            delete-by-moving-to-trash t
            wdired-allow-to-change-permissions t)
      (define-key dired-mode-map (kbd "RET") 'dired-find-alternate-file)
      (define-key dired-mode-map (kbd "C-M-u") 'dired-up-directory)
      (define-key dired-mode-map (kbd "M-o") 'my/dired-mac-open)
      (define-key dired-mode-map (kbd "C-x C-q") 'wdired-change-to-wdired-mode)
      (add-hook 'dired-mode-hook #'my/dired-mode-hook)))
#+END_SRC
** Programming Languages
Configuration options for language-specific packages live here.
*** General prog-mode hooks
In programming mode make sure:
1. FIXME and TODO are highlighted
2. =linum= mode is turned on 
3. =hl-line= is turned on

In programming mode, I use =C-c c= to comment and un-comment the 
selected region.
#+BEGIN_SRC emacs-lisp
  ;; comment/uncomment line/region
  (defun sk/comment-or-uncomment-region-or-line ()
    "Comments or uncomments the region or the current line if there's no active region."
    (interactive)
    (let (beg end)
      (if (region-active-p)
          (setq beg (region-beginning) end (region-end))
        (setq beg (line-beginning-position) end (line-end-position)))
      (comment-or-uncomment-region beg end)))

  (defun sk/init-prog-mode ()
    "Intialize programming mode"
    (font-lock-add-keywords
     nil '(("\\<\\(FIXME\\|TODO\\)\\>"
            1 '((:foreground "#d7a3ad") (:weight bold)) t)))
    (linum-mode t)
    (hl-line-mode t)
    ;; key bind
    (define-key prog-mode-map (kbd "C-c c") 'sk/comment-or-uncomment-region-or-line))

  (add-hook 'prog-mode-hook 'sk/init-prog-mode)
#+END_SRC

*** Shell
I turned off show-paren-mode (I have show-smartparen-mode anyway) and
flycheck (I don't want to run it!) as well as not blinking the
matching paren.

#+BEGIN_SRC emacs-lisp
(add-hook 'sh-mode-hook
          (lambda ()
            (show-paren-mode -1)
            (flycheck-mode -1)
            (setq blink-matching-paren nil)))
#+END_SRC

*** Elisp
This contains the configuration for elisp programming

First, turn on eldoc everywhere it's useful:

#+BEGIN_SRC emacs-lisp
(defun my/turn-on-paredit-and-eldoc ()
  (interactive)
  (paredit-mode 1)
  (eldoc-mode 1))

(add-hook 'emacs-lisp-mode-hook #'my/turn-on-paredit-and-eldoc)
(add-hook 'ielm-mode-hook #'my/turn-on-paredit-and-eldoc)
#+END_SRC

And some various eldoc settings:

#+BEGIN_SRC emacs-lisp
(use-package eldoc
  :config
  (progn
    (use-package diminish
      :init
      (progn (diminish 'eldoc-mode "ed")))
    (setq eldoc-idle-delay 0.3)
    (set-face-attribute 'eldoc-highlight-function-argument nil
                        :underline t :foreground "green"
                        :weight 'bold)))
#+END_SRC

Change the faces for elisp regex grouping:

#+BEGIN_SRC emacs-lisp
(set-face-foreground 'font-lock-regexp-grouping-backslash "#ff1493")
(set-face-foreground 'font-lock-regexp-grouping-construct "#ff8c00")
#+END_SRC

Define some niceties for popping up an ielm buffer:

#+BEGIN_SRC emacs-lisp
(defun ielm-other-window ()
  "Run ielm on other window"
  (interactive)
  (switch-to-buffer-other-window
   (get-buffer-create "*ielm*"))
  (call-interactively 'ielm))

(define-key emacs-lisp-mode-map (kbd "C-c C-z") 'ielm-other-window)
(define-key lisp-interaction-mode-map (kbd "C-c C-z") 'ielm-other-window)
#+END_SRC

Turn on elisp-slime-nav if available, so =M-.= works to jump to function
definitions:

#+BEGIN_SRC emacs-lisp
(use-package elisp-slime-nav
  :init (add-hook 'emacs-lisp-mode-hook #'elisp-slime-nav-mode))
#+END_SRC

Borrowed from Steve Purcell's config. This pretty-prints the results.

#+begin_src emacs-lisp
(bind-key "M-:" 'pp-eval-expression)

(defun sanityinc/eval-last-sexp-or-region (prefix)
 "Eval region from BEG to END if active, otherwise the last sexp."
 (interactive "P")
 (if (and (mark) (use-region-p))
 (eval-region (min (point) (mark)) (max (point) (mark)))
 (pp-eval-last-sexp prefix)))

(bind-key "C-x C-e" 'sanityinc/eval-last-sexp-or-region emacs-lisp-mode-map)
#+end_src

*** Python
I use [[https://github.com/jorgenschaefer/elpy][elpy]] as my Emacs Python development environment. Use
=elpy-config= to configure completion, syntax
checker, =linter= back-ends.

I use =virtualenv= and =virtualenvwrapper= to isolate my Python
environment for different kind of projects (research, web, general
purpose and Python 2).

For Python projects, I keep =.pyvenv= file in project's root folder
which contains the name of the Python environment configured for that
project. My Emacs automatically load the Python environment by reading
=.pyvenv= file.

#+BEGIN_SRC emacs-lisp
  (defun sk/python-project-pyvenv-name()
    (interactive)
    "Read the name of Python evironment associated with the project"
    (let* ((pyvenv-file (concat (projectile-project-root) ".pyvenv"))
           (pyvenv-file-content (f-read pyvenv-file 'utf-8)))
      (replace-regexp-in-string "\n$" "" pyvenv-file-content)))

  (defun sk/python-switch-pyvenv-for-project()
    (interactive)
    "Switch to the Python environment asscoiated with the project"
    (let ((pyvenv-name (sk/python-project-pyvenv-name)))
      (message pyvenv-name)
      ;; if Python environment is not null
      (if (and
           pyvenv-name
           (not (string-equal pyvenv-name pyvenv-virtual-env-name)))
          (pyvenv-workon pyvenv-name))))
#+END_SRC

Function below helps me select Python environment interatcively though
=ido= completion. It is bound to =C-c C-e= within =elpy= mode.

#+BEGIN_SRC emacs-lisp
  (defun sk/ido-pyvenv-workon()
    "Use `ido-completing-read' to \\[pyvenv-workon] a Python environments"
    (interactive)
    (pyvenv-workon
     (ido-completing-read
      (format "Work on (%s): " pyvenv-virtual-env-name)
      (pyvenv-virtualenv-list))))
#+END_SRC

I use =IPython= as my default Python shell for debugging and
interactive sessions. I've bound =C-c C-d= to toggle the breakpoint in
my Python buffer (it uses =ipdb.set_trace()= function).

#+BEGIN_SRC emacs-lisp
  (defface python-debugging-line-face
    '((t (:inherit hl-line
                   :background "dark red"
                   :foreground "white"
                   :weight bold)))
    "Face for ipdb line in Python")

  ;; taken from:
  ;; http://jack-kelly.com/setting_up_emacs_for_python_development
  (defun sk/python-toggle-breakpoint ()
    (interactive)
    (let* ((current-line (thing-at-point 'line))
           (ipdb-line "import ipdb; ipdb.set_trace()")
           (ipdb-regex-line (concat "^[ ]*" ipdb-line)))
      (if (string-match ipdb-regex-line current-line)
          (delete-region (line-beginning-position) (+ (line-end-position) 1))
        (save-excursion
          (move-beginning-of-line 1)
          (indent-according-to-mode)
          (insert ipdb-line)
          (newline-and-indent)
          (highlight-lines-matching-regexp ipdb-regex-line 'python-debugging-line-face)))))

#+END_SRC

Setting up =elpy= and configuring all keybindings.

#+BEGIN_SRC emacs-lisp
  (defun sk/python-mode-init ()
    ;; disable flycheck here
    (flycheck-mode -1)
    (sk/python-switch-pyvenv-for-project)
    (highlight-lines-matching-regexp "^[ ]*import ipdb; ipdb.set_trace()" 'python-debugging-line-face))

  (use-package elpy
    :config
    (progn
      (add-hook 'python-mode-hook 'sk/python-mode-init)
      ;; use ido to switch between environments
      (define-key elpy-mode-map (kbd "C-c C-e") 'sk/ido-pyvenv-workon)
      (define-key elpy-mode-map (kbd "C-c C-d") 'sk/python-toggle-breakpoint)
      (elpy-enable)
      (elpy-use-ipython)))

#+END_SRC

#+BEGIN_SRC python
print("hello")
#+END_SRC
*** Javascript
#+BEGIN_SRC emacs-lisp
(use-package js2-mode
  :init
  (progn
    (add-to-list 'auto-mode-alist '("\\.js\\'" . js2-mode))
    (defalias 'javascript-generic-mode 'js2-mode))
  :config
  (progn
    (js2-imenu-extras-setup)
    (setq-default js-auto-indent-flag nil
                  js-indent-level 2)))

#+END_SRC

There's =tern= also, but I leave it turned off by default

#+BEGIN_SRC emacs-lisp
(use-package tern
  :init ;;(add-hook 'js-mode-hook (lambda () (tern-mode t)))
  )
#+END_SRC
** Version control
*** magit
I use =M-g M-g= everywhere to go directly to Magit.

#+BEGIN_SRC emacs-lisp
  (use-package magit
    :bind ("M-g M-g" . magit-status)
    :config
    (progn
      ;; longer commit summaries
      (setq git-commit-summary-max-length 72)
      (defun magit-browse ()
        "Browse to the project's github URL, if available"
        (interactive)
        (let ((url (with-temp-buffer
                     (unless (zerop (call-process-shell-command
                                     "git remote -v" nil t))
                       (error "Failed: 'git remote -v'"))
                     (goto-char (point-min))
                     (when (re-search-forward
                            "github\\.com[:/]\\(.+?\\)\\.git" nil t)
                       (format "https://github.com/%s" (match-string 1))))))
          (unless url
            (error "Can't find repository URL"))
          (browse-url url)))

      (when (and (boundp 'moe-theme-which-enabled)
                 (eq moe-theme-which-enabled 'dark))
        ;; Moe's magit colors are baaaaaaad
        (set-face-attribute 'magit-item-highlight nil
                            :inherit nil
                            :foreground 'unspecified))

      (define-key magit-mode-map (kbd "C-c C-b") 'magit-browse)
      (define-key magit-status-mode-map (kbd "W") 'magit-toggle-whitespace)
      (custom-set-variables '(magit-set-upstream-on-push (quote dontask)))
      (setq magit-completing-read-function 'magit-ido-completing-read)
      ;; Diminish the auto-revert-mode
      (add-hook 'magit-auto-revert-mode-hook
                (diminish 'magit-auto-revert-mode))))
#+END_SRC
*** gt-gutter
Only enabled in a few modes, but quite useful, as well as the =C-x n= and =C-x
p= bindings.

#+BEGIN_SRC emacs-lisp
    (use-package git-gutter
      :bind (("C-x =" . git-gutter:popup-hunk)
             ("C-x p" . git-gutter:previous-hunk)
             ("C-x v s" . git-gutter:stage-hunk)
             ("C-x v r" . git-gutter:revert-hunk)
             ("C-x v =" . git-gutter:popup-hunk))
      :diminish
      :init (global-git-gutter-mode t)
      :config (require 'git-gutter-fringe))
#+END_SRC
** Projectile
Per-project navigation

#+BEGIN_SRC emacs-lisp
  (use-package projectile
    :diminish projectile-mode
    :init (projectile-global-mode)
    :bind (;;("C-x f" . projectile-find-file)
           ("C-c p s" . projectile-switch-project)
           ("C-c p a" . projectile-ag)
           ("C-c p g" . projectile-grep))
    :config
    (progn
      (setq projectile-switch-project-action 'projectile-dired)))
#+END_SRC
** Error Checking
*** Flycheck
Pretty minimally configured, but awesome tool for most dynamic languages.

#+BEGIN_SRC emacs-lisp
  (defun my/flycheck-customize ()
    (interactive)
    (global-set-key (kbd "C-c C-n") 'flycheck-tip-cycle)
    (global-set-key (kbd "C-c C-p") 'flycheck-tip-cycle-reverse))

  (use-package flycheck
    :defer t
    :bind (("M-g M-n" . flycheck-next-error)
           ("M-g M-p" . flycheck-previous-error)
           ("M-g M-=" . flycheck-list-errors))
    :idle (global-flycheck-mode)
    :diminish "fc"
    :config
    (progn
      (setq-default flycheck-disabled-checkers '(emacs-lisp-checkdoc))
      (use-package flycheck-color-mode-line
        :init (add-hook 'flycheck-mode-hook 'flycheck-color-mode-line-mode))
      (use-package flycheck-tip
        :config (add-hook 'flycheck-mode-hook #'my/flycheck-customize))))

#+END_SRC
*** Spell check and flyspell
I use hunspell and aspell checking spelling, ignoring words under 3 characters
and running very quickly.

First, set up some Hunspell things if applicable, falling back to aspell if
hunspell isn't available:

#+BEGIN_SRC emacs-lisp
  ;; Standard location of personal dictionary
  ;; (setq ispell-personal-dictionary "~/.flydict")
  (if (file-exists-p "/usr/local/bin/hunspell")
      (progn
        ;; Add english-hunspell as a dictionary
        (setq-default ispell-program-name "hunspell"
                      ispell-dictionary "en_US"))
    (progn (setq-default ispell-program-name "aspell")
           (setq ispell-extra-args '("--sug-mode=normal" "--ignore=3"))))

  (add-to-list 'ispell-skip-region-alist '("[^\000-\377]+"))
#+END_SRC

In most non-programming modes, =M-.= can be used to spellcheck the word
(otherwise it would jump to the definition)

#+BEGIN_SRC emacs-lisp
  ;; flyspell
  (use-package flyspell
    :diminish "FS"
    :config
    (define-key flyspell-mode-map (kbd "M-n") 'flyspell-goto-next-error)
    (define-key flyspell-mode-map (kbd "M-.") 'ispell-word))
#+END_SRC

** Text modes
*** ediff
Ediff is fantastic for looking through diffs, a lot of these settings are taken
from http://oremacs.com/2015/01/17/setting-up-ediff/

#+BEGIN_SRC emacs-lisp
(defun my/setup-ediff ()
  (interactive)
  (ediff-setup-keymap)
  (define-key ediff-mode-map "j" #'ediff-next-difference)
  (define-key ediff-mode-map "k" #'ediff-previous-difference))

(use-package ediff
  :init (add-hook 'ediff-mode-hook 'my/setup-ediff)
  :config
  (progn
    (setq
     ;; Always split nicely for wide screens
     ediff-split-window-function 'split-window-horizontally
     ;; Ignore whitespace
     ediff-diff-options "-w")))
#+END_SRC

*** vlf (view large files)
[[https://github.com/m00natic/vlfi][VLF]] lets me handle things like 2gb files gracefully.

#+BEGIN_SRC emacs-lisp
(use-package vlf-setup)
#+END_SRC

** org-reveal (ox-reveal)
Exporting org-mode to [[http://lab.hakim.se/reveal-js/#/][reveal.js]] presentations

#+BEGIN_SRC emacs-lisp
(use-package ox-reveal
  :config
  (progn
    (setq org-reveal-root "http://cdn.jsdelivr.net/reveal.js/2.5.0/")))
#+END_SRC

** Completion frameworks
*** Yasnippet
#+BEGIN_SRC emacs-lisp
  ;; yasn\ippet
  (use-package yasnippet
    :defer t
    :config
    (progn
      (yas-global-mode)
      (unbind-key "<tab>" yas-minor-mode-map)
      (unbind-key "TAB" yas-minor-mode-map)
      (bind-key "C-c y" 'yas-expand yas-minor-mode-map)
      (custom-set-variables '(yas/prompt-functions '(my-yas/prompt))))
    :idle (yas-reload-all))
#+END_SRC
*** Company mode
Standard auto-completion configuration with company-mode

#+BEGIN_SRC emacs-lisp
(use-package company
  :diminish " C"
  :bind ("C-." . company-complete)
  :config
  (progn
    (setq company-idle-delay 0.2
          ;; min prefix of 2 chars
          company-minimum-prefix-length 2
          company-selection-wrap-around t
          company-show-numbers t
          company-dabbrev-downcase nil
          company-transformers '(company-sort-by-occurrence))
    (bind-keys :map company-active-map
               ("C-n" . company-select-next)
               ("C-p" . company-select-previous)
               ("C-d" . company-show-doc-buffer)
               ("<tab>" . company-complete))))

(add-hook 'prog-mode-hook 'company-mode)
#+END_SRC

*** abbrev
I use abbrev-mode to automatically correct misspellings I usually make.

#+BEGIN_SRC emacs-lisp
(use-package abbrev
  :diminish ""
  :config
  (progn
    (define-key ctl-x-map "\C-a" 'my/ispell-word-then-abbrev)

    (defun my/ispell-word-then-abbrev (p)
      "Call `ispell-word'. Then create an abbrev for the correction made.
With prefix P, create local abbrev. Otherwise it will be global."
      (interactive "P")
      (let ((bef (downcase (or (thing-at-point 'word) ""))) aft)
        (call-interactively 'ispell-word)
        (setq aft (downcase (or (thing-at-point 'word) "")))
        (unless (string= aft bef)
          (message "\"%s\" now expands to \"%s\" %sally"
                   bef aft (if p "loc" "glob"))
          (define-abbrev
            (if p local-abbrev-table global-abbrev-table)
            bef aft))))

    (setq save-abbrevs t)
    (setq-default abbrev-mode t)))

(defun my/enable-abbrev-mode ()
  (interactive)
  (abbrev-mode t))

(add-hook 'prog-mode-hook #'my/enable-abbrev-mode)
#+END_SRC

From https://github.com/purcell/emacs.d/blob/master/lisp/init-auto-complete.el -
Exclude very large buffers from dabbrev

#+begin_src emacs-lisp
(defun sanityinc/dabbrev-friend-buffer (other-buffer)
 (< (buffer-size other-buffer) (* 1 1024 1024)))
(setq dabbrev-friend-buffer-function 'sanityinc/dabbrev-friend-buffer)
#+end_src

*** smart-tab
Used smart-tab to complete everywhere except for ERC, shell and mu4e.

#+BEGIN_SRC emacs-lisp
(use-package smart-tab
  :diminish ""
  :config
  (progn
    (add-to-list 'smart-tab-disabled-major-modes 'mu4e-compose-mode)
    (add-to-list 'smart-tab-disabled-major-modes 'erc-mode)
    (add-to-list 'smart-tab-disabled-major-modes 'shell-mode)))

(add-hook 'prog-mode-hook (lambda () (global-smart-tab-mode 1)))
#+END_SRC

** eww
Ewwwwww...

Wait, no, I mean the Emacs web browser built in to 24.4

#+BEGIN_SRC emacs-lisp
(use-package eww
  :init
  (progn
    (define-prefix-command 'my/eww-map)
    (define-key ctl-x-map "w" 'my/eww-map)

    (define-key my/eww-map "t" 'eww)
    (define-key my/eww-map "o" 'eww)
    (define-key my/eww-map "w" 'my/eww-wiki)
    (define-key my/eww-map "e" 'my/search-es-docs)

    (defun my/eww-wiki (text)
      "Function used to search wikipedia for the given text."
      (interactive (list (read-string "Wiki for: ")))
      (eww (format "https://en.m.wikipedia.org/wiki/Special:Search?search=%s"
                   (url-encode-url text)))))
  :config
  (progn
    (define-key eww-mode-map "o" 'eww)
    (define-key eww-mode-map "O" 'eww-browse-with-external-browser)
    (use-package eww-lnum
      :init
      (eval-after-load "eww"
        '(progn (define-key eww-mode-map "f" 'eww-lnum-follow)
                (define-key eww-mode-map "F" 'eww-lnum-universal))))))
#+END_SRC
** Utility methods
Various methods I call interactively for things.
*** Recompile startup elisp files
Byte-compile startup stuff.

#+BEGIN_SRC emacs-lisp
(defun sk/byte-recompile-init-files ()
  "Recompile all of the startup files"
  (interactive)
  (byte-recompile-directory "~/.emacs.d" 0))
#+END_SRC
